# 算法Leetcode笔记
----------
### 1算法思想
#### 1.1递归
* 递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。
* 我的⼀点⼼得是：明⽩⼀个函数的作⽤并相信它能完成这个任务，千万不要 试图跳进细节。千万不要跳进这个函数⾥⾯企图探究更多细节，否则就会陷 ⼊⽆穷的细节⽆法⾃拔
* 显然有时候递归处理是⾼效的，⽐如归并排序，有时候是低效的，⽐如数孙 悟空⾝上的⽑，因为堆栈会消耗额外空间
``` JAVA
int func(你今年几岁) { 
// 最简子问题，结束条件 
if (你1999年0岁) return 我0岁; 
// 自我调用，缩小规模 
return func(你去年几岁) + 1; }
```
* 1、为了训练逆向思考的能⼒。递推的思维是正常⼈的思维，总是看着眼前的问题思考对策，解决问题是将来时；递归的思维，逼迫我们倒着思考，看 到问题的尽头，把解决问题的过程看做过去时。 
* 2、练习分析问题的结构，当问题可以被分解成相同结构的⼩问题时，你 能敏锐发现这个特点，进⽽⾼效解决问题。 
* 3、跳出细节，从整体上看问题。再说说归并排序，其实可以不⽤递归来 划分左右区域的，但是代价就是代码极其难以理解。

#### 1.2分治
* 分治，典型的递归结构；
* 分治算法可以分三步走：分解 -> 解决 -> 合并
* 1. 分解原问题为结构相同的⼦问题。 
* 2. 分解到某个容易求解的边界之后，进⾏第归求解。 
* 3. 将⼦问题的解合并成原问题的解。

### 2.数据结构
	1、数据结构的**存储方式**只有两种：数组 和 链表；
	2、数据结构的**遍历方式**只有两种：线性（for/while） 和 非线性（递归）；
		思考：数组怎么遍历、链表怎么遍历、二叉树怎么遍历？图怎么遍历？ 
		---> 你看二叉树的递归遍历式和链表的递归遍历式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多二条叉，N 叉树你会不会遍历？
		---> N 叉树的遍历可以扩展为图的遍历，因为图就是多个二叉棵树的结合体。
	
#### 2.1二叉树
* 总路线：明确一个节点要做的事情，然后剩下的事抛给框架
``` Java
void traverse(TreeNode root) { 
// root 需要做什么？在这做。 
// 其他的不用root 操心，抛给框架 
traverse(root.left);
traverse(root.right); }
```

#### 2.2二叉搜索树BST
* 利用BST左边子树节点全都小于等于根结点，右子树节点全都大于等于根节点的特性，在二叉树的框架上进行改造；
* BST求最大最小值，直接while循环找到最后一个left，或者right节点即可；
```Java
void BST(TreeNode root, int target) { 
	if (root.val == target) 
		// 找到⽬标，做点什么 
	if (root.val < target) 
		BST(root.right, target); 
	if (root.val > target) 
		BST(root.left, target); 	
}
```
* 对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。
* 我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。
* 一旦涉及“改”，函数就要返回 TreeNode 类型， 并且对递归调用的返回值进行接收，框架如下；
```java
TreeNode BST(TreeNode root, int target) { 
	if (root.val == target)  //也不一定是判断target，这块就是要做的事 
		// 找到⽬标，做点什么 
	if (root.val < target) 
		root.right = BST(root.right, target); 
	if (root.val > target) 
		root.left = BST(root.left, target); 	
}
```
总结：叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。

#### 2.3二叉堆
* 堆通常是一个可以被看做一棵树的**数组对象**。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。
* 二叉堆（Binary Heap）没什么神秘，性质二叉搜索树 BST 还简单。其主要操作就两个， sink （下沉）和 swim （上浮），用以维护二叉堆的性 质。其主要应用有两个，1是排序方法「堆排序」，2是很有用的数据结构「优先级队列」。
* 二叉堆其实就是1种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针，把 arr[1] 作为整棵树的根；
* 二叉最小堆的性质是：每个节点都小于等于它的两个子节点。
* 二叉最大堆的性质是：每个节点都大于等于它的两个子节点。
* 优先级队列是基于二叉堆实现的，主要操作是插入和删除。插入是先插到最后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位置。
* JAVA有实现好的优先级队列（二叉小顶堆实现、数组存储），可以直接拿来用：优先队列的头是基于自然排序或者Comparator排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。当我们获取队列时，返回队列的头对象；PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。
* [JAVA优先级队列完全介绍](https://www.cnblogs.com/Elliott-Su-Faith-change-our-life/p/7472265.html)
* 场景： **堆排序、topK问题**；由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。
``` JAVA
PriorityQueue<ListNode> queue = new PriorityQueue<>(lists.length, new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                if (o1.val < o2.val) return -1;
                else if (o1.val == o2.val) return 0;
                else return 1;
            }
        });
```

#### 2.4图论
* 图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。
* 图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。
##### 2.4.1邻接矩阵
目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。
![图](https://mmbiz.qlogo.cn/mmbiz_jpg/TdGLaSU675gwBawZm4AtKbyUUqEHRqCKdrwRIiaF81ZviavKF6EMccBEnwrxXLpmSdpW1tYZAconjxMmN45GhJVA/0?wx_fmt=jpeg)
* 有向图由于边具有**方向性**，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。
用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致**二维数组的大小剧增**，从而占用大量的内存空间。
* 而根据实际情况可以分析得，图中的顶点并**不是任意两个顶点间都会相连**，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会**存在大量的0**。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。
* 因此，为了解决上述问题，一种可以只存储相连顶点关系的**邻接表**应运而生。
##### 2.4.2邻接表
在邻接表中，图的每一个顶点都是一个**链表的头节点**，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。
![邻接表](https://mmbiz.qlogo.cn/mmbiz_jpg/TdGLaSU675gwBawZm4AtKbyUUqEHRqCKOL0EumFMatB8WibkochP6ztLGj5fncWOSw0FAgKOICdiaE13o92f1umg/0?wx_fmt=jpeg)
```
入度：有向图的某个顶点作为终点的次数和。
出度：有向图的某个顶点作为起点的次数和。
```
* ，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表;

##### 2.4.3逆邻接表
* 逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。
![逆邻接表](https://mmbiz.qlogo.cn/mmbiz_jpg/TdGLaSU675gwBawZm4AtKbyUUqEHRqCKUFCtCibxkjpduYK7DOCBlPM9MHKK4b48O5L1DYGOiatjuvNFyfPCDQGQ/0?wx_fmt=jpeg)
* 邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，**邻接表和逆邻接表实际上有一部分数据时重合**的，因此可以将两个表合二为一，从而得到了所谓的十字链表。

##### 2.4.4十字链表
十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。
![十字链表](https://mmbiz.qpic.cn/mmbiz_jpg/TdGLaSU675gwBawZm4AtKbyUUqEHRqCKORBfPSQiblo2CLzrahdcNeqMvzm93kKiaybG4iaCD2TKH4vs8IkxRmppw/640?wx_fmt=jpeg)
* 但这并不是最优的表示方式。虽然这样的方式**共用了中间的顶点存储空间**，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。
* 十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）
```
data：用于存储该顶点中的数据；
firstin指针：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；
firstout指针：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点；
```
* 边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：
```
tailvex：用于存储作为弧尾的顶点的编号；
headvex：用于存储作为弧头的顶点的编号；
headlink 指针：用于链接下一个存储作为弧头的顶点的节点；
taillink 指针：用于链接下一个存储作为弧尾的顶点的节点
```
![](https://mmbiz.qpic.cn/mmbiz_jpg/TdGLaSU675gwBawZm4AtKbyUUqEHRqCKsPXqiaIeicYpPEBPrs3jVRs795hLAUQ44748sjFLWhnsZ7fGL2OkicJ6g/640?wx_fmt=jpeg)
以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边AE（即边04）指向顶点E，顶点A的firstout指针需要指向边04的tailvex。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边AB（即边10）指向B，顶点A的firstin指针需要指向边10的弧头，即headlink指针。依次类推。
##### 2.4.5动态连通性
* 动态连通性其实可以抽象成给1幅图连线，总共 有 10 个节点，他们互不相连，分别用0~9 标记：
```
这⾥所说的「连通」是⼀种等价关系，也就是说具有如下三个性质： 
1、⾃反性：节点 p 和 p 是连通的。 
2、对称性：如果节点 p 和 q 连通，那么 q 和 p 也连通。 
3、传递性：如果节点 p 和 q 连通， q 和 r 连通，那么 p 和 r 也连通
```
* **连通分量**
0〜9 任意两个不同的点都不连通，调⽤ connected 都 会返回 false，连通分量为 10 个。 如果现在调⽤ union(0, 1) ，那么 0 和 1 被连通，连通分量降为 9 个。 再调⽤ union(1, 2) ，这时 0,1,2 都被连通，调⽤ connected(0, 2) 也会返回 true，连通分量变为 8 个。

#### 2.5 散列表（哈希表）
* 散列表也叫哈希表，是一种通过键值对直接访问数据的结构；散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。
* 常用的有以下几种散列函数：
```
直接寻址法：取关键字或关键字的某个线性函数值为散列地址。
数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。
平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。
取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。
除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。
```
* 确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。
* 常用的冲突处理方式有很多，常用的包括以下几种：
```
开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。
再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。
**链地址法**最常用：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。
公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。
```




### 3.查找算法汇总
#### 3.1二分查找
* 场景：除了课本上的对有序数组搜索之外。当搜索空间有序的时候，就可以通过⼆分搜索「剪枝」，大幅提升效率。
* 场景展示：有一个for 循环，就是在连续的空间线性搜索，这就是二分查找可以发挥作用的标志。由于我们要求的是最小速度，所以可以用一个搜索左侧边界的二分查找来代替线性搜索；
* 简单来说，就是for循环遍历i，查看第一个满足条件的i时候，就可以直接用二分查找遍历。
* 1、分析2分查找代码时，不要出现 else，全部展开成 else if ⽅便理解。 
* 2、注意「搜索区间」和 while 的终⽌条件，如果存在漏掉的元素，记得在 最后检查。
* 3、如需要搜索左右边界，只要在 nums[mid] == target 时做修改即可。搜索 右侧时需要减1。
##### 3.1.1最基本的二分查找（找到就行，不一定要第一个）
``` JAVA
因为我们初始化 right = nums.length - 1 
所以决定了我们的「搜索区间」是 [left, right] 
所以决定了 while (left <= right) 
同时也决定了 left = mid+1 和 right = mid-1 
因为我们只需找到⼀个 target 的索引即可 
所以当 nums[mid] == target 时可以即返回
```

##### 3.1.2寻找左侧边界的二分查找：
* 对于搜索左侧边界的⼆分查找，有⼀个 特殊性质： 当 val 不存在时，得到的索引恰好是⽐ val⼤的最⼩元素索引；什么意思呢，就是说如果在数组 [0,1,3,4] 中搜索元素 2，算法会返回索 引 2，也就是元素 3 的位置，元素 3 是数组中⼤于 2 的最⼩元素
``` JAVA
因为我们初始化 right = nums.length 
所以决定了我们的「搜索区间」是 [left, right) 
所以决定了 while (left < right) 
同时也决定了 left = mid + 1 和 right = mid
因为我们需找到 target 的最左侧索引 
所以当 nums[mid] == target 时不要立即返回 
要收紧右侧边界以锁定左侧边界
```

##### 3.1.3寻找右侧边界的二分查找
``` JAVA
因为我们初始化 right = nums.length 
所以决定了我们的「搜索区间」是 [left, right) 
所以决定了 while (left < right) 
同时也决定了 left = mid + 1 和 right = mid 
因为我们需找到 target 的最右侧索引 
所以当 nums[mid] == target 时不要立即返回 
要收紧左侧边界以锁定右侧边界 
因为收紧左侧边界时必须 left = mid + 1
```

### 4.算法技巧
* 主要总结一些做算法题过程中遇到的技巧性方法；

#### 4.1双指针技巧
##### 4.1.1快慢指针
* 原理：快慢指针一般都初始化指向链表的头结点head，前进时快指针fast 在前， 慢指针slow 在后；
* 场景：**链表**的问题
* 举例：判断链表是否有环；已知链表中含有环，返回这个环的起始位置；寻找链表的中点；寻找链表的倒数第 k 个元素；
``` Java
// Initialize slow & fast pointers
ListNode slow = head;
ListNode fast = head;
/**
 * Change this condition to fit specific problem.
 * Attention: remember to avoid null-pointer error
 **/
while (slow != null && fast != null && fast.next != null) {
    slow = slow.next;           // move slow pointer one step each time
    fast = fast.next.next;      // move fast pointer two steps each time
    if (slow == fast) {         // change this condition to fit specific problem
        return true;
    }
}
return false;   // change return value to fit specific problem
```
* 各个数据结构时空复杂度比较
![compare](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/04/29/screen-shot-2018-04-28-at-174531.png)
##### 4.1.2左右指针  
* 原理：左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1；
* 场景：**数组**问题、**字符串**问题；
* 举例：二分查找；两数之和；反转数组；滑动窗口算法；


#### 4.2滑动窗口技巧
* 原理：双指针扫描，左右指针均从0开始；右指针向右扫描直到满足条件停止，记录此时的值；左指针向右扫描直到不满足条件停止；重复这个步骤一直到右指针到尾部；最终得到一个最优的值；
* 场景：秒杀高难度的**子字符串匹配**问题；
* 实现：双指针扫描数组、hashmap存储字符串频率、while循环遍历；

#### 4.3二维数组转一维
``` JAVA
int get_array( int x, int y ) { return array[ x * SIZE_Y + y ]; }
```

#### 位操作
* 利⽤或操作 | 和空格将英⽂字符转换为⼩写
``` JAVA
('a' | ' ') = 'a' 
('A' | ' ') = 'a'
```
* 利⽤与操作 & 和下划线将英⽂字符转换为⼤写
``` JAVA
('b' & '_') = 'B' 
('B' & '_') = 'B'
```
* 利⽤异或操作 ^ 和空格进⾏英⽂字符⼤⼩写互换
``` JAVA
('d' ^ ' ') = 'D' 
('D' ^ ' ') = 'd'
```
* 以上转换主要是因为ASCII 编码，空格(Space)的ASCII码值是:32，10 0000

* 判断两个数是否异号
``` JAVA
int x = -1, y = 2; 
bool f = ((x ^ y) < 0); // true 
int x = 3, y = 2; 
bool f = ((x ^ y) < 0); // false
```

* 常用操作n&(n-1) ->用于消除数字n的二进制表示的最后一个1
	* 汉明权重（判断一个数二进制表示中1的个数）
	* 判断一个数是不是2的指数



### 5.做题遇到的算法问题
* 在排序的数组中交换两个元素： https://blog.csdn.net/zjx409/article/details/47017063?utm_source=blogxgwz7
* ⼀个数和它本⾝做异 或运算结果为 0，⼀个数和 0 做异或运算还是它本⾝。


#### 5.1LRU - 最近最少使用Least Rencently Use
* 采用双向链表 + 哈希表实现
* 主要就是 get（在最近使用过的里面，又使用了一次，那么这个就得提前到队首）  和 put（最近未使用过，第一次用，先加入map再提前到队首，并把之前的队尾删除）；